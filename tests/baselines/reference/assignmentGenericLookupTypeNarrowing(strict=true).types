//// [tests/cases/conformance/expressions/assignmentOperator/assignmentGenericLookupTypeNarrowing.ts] ////

=== assignmentGenericLookupTypeNarrowing.ts ===
// Repro from #26130

let mappedObject: {[K in "foo"]: null | {x: string}} = {foo: {x: "hello"}};
>mappedObject : { foo: { x: string; } | null; }
>             : ^^^^^^^^^^^^      ^^^^^^^^^^^^^
>x : string
>  : ^^^^^^
>{foo: {x: "hello"}} : { foo: { x: string; }; }
>                    : ^^^^^^^^^^^^^^^^^^^^^^^^
>foo : { x: string; }
>    : ^^^^^^^^^^^^^^
>{x: "hello"} : { x: string; }
>             : ^^^^^^^^^^^^^^
>x : string
>  : ^^^^^^
>"hello" : "hello"
>        : ^^^^^^^

declare function foo<T>(x: T): null | T;
>foo : <T>(x: T) => null | T
>    : ^ ^^^^^ ^^^^^        
>x : T
>  : ^

function bar<K extends "foo">(key: K) {
>bar : <K extends "foo">(key: K) => void
>    : ^ ^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^
>key : K
>    : ^

  const element = foo(mappedObject[key]);
>element : { foo: { x: string; } | null; }[K] | null
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>foo(mappedObject[key]) : { foo: { x: string; } | null; }[K] | null
>                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>foo : <T>(x: T) => T | null
>    : ^^^^^^^^^^^^^^^^^^^^^
>mappedObject[key] : { foo: { x: string; } | null; }[K]
>                  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>mappedObject : { foo: { x: string; } | null; }
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>key : K
>    : ^

  if (element == null)
>element == null : boolean
>                : ^^^^^^^
>element : { foo: { x: string; } | null; }[K] | null
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    return;
  const x = element.x;
>x : string
>  : ^^^^^^
>element.x : string
>          : ^^^^^^
>element : { x: string; }
>        : ^^^^^^^^^^^^^^
>x : string
>  : ^^^^^^
}

