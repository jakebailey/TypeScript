//// [tests/cases/compiler/indirectTypeParameterReferences.ts] ////

=== indirectTypeParameterReferences.ts ===
// Repro from #19043

type B = {b: string}
>B : { b: string; }
>b : string

const flowtypes = <A>(b: B) => {
>flowtypes : <A>(b: B) => { combined: (fn: (combined: A & B) => void) => null; literal: (fn: (aPlusB: A & B) => void) => null; }
><A>(b: B) => {  type Combined = A & B  const combined = (fn: (combined: Combined) => void) => null  const literal = (fn: (aPlusB: A & B) => void) => null  return {combined, literal}} : <A>(b: B) => { combined: (fn: (combined: A & B) => void) => null; literal: (fn: (aPlusB: A & B) => void) => null; }
>b : B

  type Combined = A & B
>Combined : A & B

  const combined = (fn: (combined: Combined) => void) => null
>combined : (fn: (combined: A & B) => void) => null
>(fn: (combined: Combined) => void) => null : (fn: (combined: A & B) => void) => null
>fn : (combined: A & B) => void
>combined : A & B

  const literal = (fn: (aPlusB: A & B) => void) => null
>literal : (fn: (aPlusB: A & B) => void) => null
>(fn: (aPlusB: A & B) => void) => null : (fn: (aPlusB: A & B) => void) => null
>fn : (aPlusB: A & B) => void
>aPlusB : A & B

  return {combined, literal}
>{combined, literal} : { combined: (fn: (combined: A & B) => void) => null; literal: (fn: (aPlusB: A & B) => void) => null; }
>combined : (fn: (combined: A & B) => void) => null
>literal : (fn: (aPlusB: A & B) => void) => null
}

const {combined, literal} = flowtypes<{a: string}>({b: 'b-value'})
>combined : (fn: (combined: { a: string; } & B) => void) => null
>literal : (fn: (aPlusB: { a: string; } & B) => void) => null
>flowtypes<{a: string}>({b: 'b-value'}) : { combined: (fn: (combined: { a: string; } & B) => void) => null; literal: (fn: (aPlusB: { a: string; } & B) => void) => null; }
>flowtypes : <A>(b: B) => { combined: (fn: (combined: A & B) => void) => null; literal: (fn: (aPlusB: A & B) => void) => null; }
>a : string
>{b: 'b-value'} : { b: string; }
>b : string
>'b-value' : "b-value"

literal(aPlusB => {
>literal(aPlusB => {  aPlusB.b  aPlusB.a}) : null
>literal : (fn: (aPlusB: { a: string; } & B) => void) => null
>aPlusB => {  aPlusB.b  aPlusB.a} : (aPlusB: { a: string; } & B) => void
>aPlusB : { a: string; } & B

  aPlusB.b
>aPlusB.b : string
>aPlusB : { a: string; } & B
>b : string

  aPlusB.a
>aPlusB.a : string
>aPlusB : { a: string; } & B
>a : string

})

combined(comb => {
>combined(comb => {  comb.b  comb.a}) : null
>combined : (fn: (combined: { a: string; } & B) => void) => null
>comb => {  comb.b  comb.a} : (comb: { a: string; } & B) => void
>comb : { a: string; } & B

  comb.b
>comb.b : string
>comb : { a: string; } & B
>b : string

  comb.a
>comb.a : string
>comb : { a: string; } & B
>a : string

})

// Repro from #19091

declare function f<T>(a: T): { a: typeof a };
>f : <T>(a: T) => {    a: typeof a;}
>a : T
>a : T
>a : T

let n: number = f(2).a;
>n : number
>f(2).a : number
>f(2) : { a: number; }
>f : <T>(a: T) => { a: T; }
>2 : 2
>a : number

