//// [tests/cases/compiler/restTypesShouldBeMutable.ts] ////

=== restTypesShouldBeMutable.ts ===
declare function callFn<T extends readonly any[]>(args: T, fn: (...args: T) => void): void;
>callFn : Symbol(callFn, Decl(restTypesShouldBeMutable.ts, 0, 0))
>T : Symbol(T, Decl(restTypesShouldBeMutable.ts, 0, 24))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 0, 50))
>T : Symbol(T, Decl(restTypesShouldBeMutable.ts, 0, 24))
>fn : Symbol(fn, Decl(restTypesShouldBeMutable.ts, 0, 58))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 0, 64))
>T : Symbol(T, Decl(restTypesShouldBeMutable.ts, 0, 24))

declare const input: readonly string[];
>input : Symbol(input, Decl(restTypesShouldBeMutable.ts, 2, 13))

callFn(input, (...args) => {
>callFn : Symbol(callFn, Decl(restTypesShouldBeMutable.ts, 0, 0))
>input : Symbol(input, Decl(restTypesShouldBeMutable.ts, 2, 13))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 4, 15))

    args;
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 4, 15))

    args[0] = "hello";
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 4, 15))

})

declare function callFnNonGeneric(args: readonly string[], fn: (...args: readonly string[]) => void): void;
>callFnNonGeneric : Symbol(callFnNonGeneric, Decl(restTypesShouldBeMutable.ts, 7, 2))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 9, 34))
>fn : Symbol(fn, Decl(restTypesShouldBeMutable.ts, 9, 58))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 9, 64))

callFnNonGeneric(input, (...args) => {
>callFnNonGeneric : Symbol(callFnNonGeneric, Decl(restTypesShouldBeMutable.ts, 7, 2))
>input : Symbol(input, Decl(restTypesShouldBeMutable.ts, 2, 13))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 11, 25))

    args;
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 11, 25))

    args[0] = "hello";
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 11, 25))

})


declare function callFnTuple<T extends readonly [string, string, string]>(args: T, fn: (...args: T) => void): void;
>callFnTuple : Symbol(callFnTuple, Decl(restTypesShouldBeMutable.ts, 14, 2))
>T : Symbol(T, Decl(restTypesShouldBeMutable.ts, 17, 29))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 17, 74))
>T : Symbol(T, Decl(restTypesShouldBeMutable.ts, 17, 29))
>fn : Symbol(fn, Decl(restTypesShouldBeMutable.ts, 17, 82))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 17, 88))
>T : Symbol(T, Decl(restTypesShouldBeMutable.ts, 17, 29))

declare const inputTuple: readonly [string, string, string];
>inputTuple : Symbol(inputTuple, Decl(restTypesShouldBeMutable.ts, 19, 13))

callFnTuple(inputTuple, (...args) => {
>callFnTuple : Symbol(callFnTuple, Decl(restTypesShouldBeMutable.ts, 14, 2))
>inputTuple : Symbol(inputTuple, Decl(restTypesShouldBeMutable.ts, 19, 13))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 21, 25))

    args;
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 21, 25))

    args[0] = "hello";
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 21, 25))
>0 : Symbol(0)

})

declare function callFnNonGenericTuple(args: readonly [string, string, string], fn: (...args: readonly [string, string, string]) => void): void;
>callFnNonGenericTuple : Symbol(callFnNonGenericTuple, Decl(restTypesShouldBeMutable.ts, 24, 2))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 26, 39))
>fn : Symbol(fn, Decl(restTypesShouldBeMutable.ts, 26, 79))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 26, 85))

callFnNonGenericTuple(inputTuple, (...args) => {
>callFnNonGenericTuple : Symbol(callFnNonGenericTuple, Decl(restTypesShouldBeMutable.ts, 24, 2))
>inputTuple : Symbol(inputTuple, Decl(restTypesShouldBeMutable.ts, 19, 13))
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 28, 35))

    args;
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 28, 35))

    args[0] = "hello";
>args : Symbol(args, Decl(restTypesShouldBeMutable.ts, 28, 35))
>0 : Symbol(0)

})

