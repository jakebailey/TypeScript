//// [tests/cases/compiler/optionalFunctionArgAssignability.ts] ////

=== optionalFunctionArgAssignability.ts ===
interface Promise<T> {
    then<U>(onFulfill?: (value: T) => U, onReject?: (reason: any) => U): Promise<U>;
>then : { <TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>; <U>(onFulfill?: ((value: T) => U) | undefined, onReject?: ((reason: any) => U) | undefined): Promise<U>; }
>onFulfill : ((value: T) => U) | undefined
>value : T
>onReject : ((reason: any) => U) | undefined
>reason : any
}
 
var a = function then<U>(onFulfill?: (value: string) => U, onReject?: (reason: any) => U): Promise<U> { return null };
>a : <U>(onFulfill?: ((value: string) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>
>function then<U>(onFulfill?: (value: string) => U, onReject?: (reason: any) => U): Promise<U> { return null } : <U>(onFulfill?: ((value: string) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>
>then : <U>(onFulfill?: ((value: string) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>
>onFulfill : ((value: string) => U) | undefined
>value : string
>onReject : ((reason: any) => U) | undefined
>reason : any

var b = function then<U>(onFulFill?: (value: number) => U, onReject?: (reason: any) => U): Promise<U> { return null };
>b : <U>(onFulFill?: ((value: number) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>
>function then<U>(onFulFill?: (value: number) => U, onReject?: (reason: any) => U): Promise<U> { return null } : <U>(onFulFill?: ((value: number) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>
>then : <U>(onFulFill?: ((value: number) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>
>onFulFill : ((value: number) => U) | undefined
>value : number
>onReject : ((reason: any) => U) | undefined
>reason : any

a = b; // error because number is not assignable to string
>a = b : <U>(onFulFill?: ((value: number) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>
>a : <U>(onFulfill?: ((value: string) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>
>b : <U>(onFulFill?: ((value: number) => U) | undefined, onReject?: ((reason: any) => U) | undefined) => Promise<U>

