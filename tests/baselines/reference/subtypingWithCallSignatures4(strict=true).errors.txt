subtypingWithCallSignatures4.ts(3,14): error TS2564: Property 'foo' has no initializer and is not definitely assigned in the constructor.
subtypingWithCallSignatures4.ts(4,30): error TS2564: Property 'bar' has no initializer and is not definitely assigned in the constructor.
subtypingWithCallSignatures4.ts(5,34): error TS2564: Property 'baz' has no initializer and is not definitely assigned in the constructor.
subtypingWithCallSignatures4.ts(6,35): error TS2564: Property 'bing' has no initializer and is not definitely assigned in the constructor.
subtypingWithCallSignatures4.ts(8,18): error TS7010: 'foo1', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(11,18): error TS7010: 'foo2', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(14,18): error TS7010: 'foo3', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(17,18): error TS7010: 'foo4', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(20,18): error TS7010: 'foo5', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(23,18): error TS7010: 'foo6', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(26,18): error TS7010: 'foo11', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(29,18): error TS7010: 'foo15', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(32,18): error TS7010: 'foo16', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(35,18): error TS7010: 'foo17', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(41,18): error TS7010: 'foo18', which lacks return-type annotation, implicitly has an 'any' return type.
subtypingWithCallSignatures4.ts(53,26): error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(54,27): error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(83,70): error TS2352: Conversion of type 'null' to type 'T' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
  'T' could be instantiated with an arbitrary type which could be unrelated to 'null'.
subtypingWithCallSignatures4.ts(84,58): error TS2352: Conversion of type 'null' to type 'T' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
  'T' could be instantiated with an arbitrary type which could be unrelated to 'null'.
subtypingWithCallSignatures4.ts(89,62): error TS2352: Conversion of type 'null' to type 'Base' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(90,60): error TS2352: Conversion of type 'null' to type 'Base' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(95,44): error TS2352: Conversion of type 'null' to type 'U[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(96,41): error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(101,53): error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(102,54): error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(107,37): error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
subtypingWithCallSignatures4.ts(110,37): error TS2352: Conversion of type 'null' to type 'any[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.


==== subtypingWithCallSignatures4.ts (27 errors) ====
    // checking subtype relations for function types as it relates to contextual signature instantiation
    
    class Base { foo: string; }
                 ~~~
!!! error TS2564: Property 'foo' has no initializer and is not definitely assigned in the constructor.
    class Derived extends Base { bar: string; }
                                 ~~~
!!! error TS2564: Property 'bar' has no initializer and is not definitely assigned in the constructor.
    class Derived2 extends Derived { baz: string; }
                                     ~~~
!!! error TS2564: Property 'baz' has no initializer and is not definitely assigned in the constructor.
    class OtherDerived extends Base { bing: string; }
                                      ~~~~
!!! error TS2564: Property 'bing' has no initializer and is not definitely assigned in the constructor.
    
    declare function foo1(a: <T>(x: T) => T[]);
                     ~~~~
!!! error TS7010: 'foo1', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo1(a: any): any;
    
    declare function foo2(a2: <T>(x: T) => string[]);
                     ~~~~
!!! error TS7010: 'foo2', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo2(a: any): any;
    
    declare function foo3(a3: <T>(x: T) => void);
                     ~~~~
!!! error TS7010: 'foo3', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo3(a: any): any;
    
    declare function foo4(a4: <T, U>(x: T, y: U) => string);
                     ~~~~
!!! error TS7010: 'foo4', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo4(a: any): any;
    
    declare function foo5(a5: <T, U>(x: (arg: T) => U) => T);
                     ~~~~
!!! error TS7010: 'foo5', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo5(a: any): any;
    
    declare function foo6(a6: <T extends Base>(x: (arg: T) => Derived) => T);
                     ~~~~
!!! error TS7010: 'foo6', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo6(a: any): any;
    
    declare function foo11(a11: <T>(x: { foo: T }, y: { foo: T; bar: T }) => Base);
                     ~~~~~
!!! error TS7010: 'foo11', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo11(a: any): any;
    
    declare function foo15(a15: <T>(x: { a: T; b: T }) => T[]);
                     ~~~~~
!!! error TS7010: 'foo15', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo15(a: any): any;
    
    declare function foo16(a16: <T extends Base>(x: { a: T; b: T }) => T[]);
                     ~~~~~
!!! error TS7010: 'foo16', which lacks return-type annotation, implicitly has an 'any' return type.
    declare function foo16(a: any): any;
    
    declare function foo17(a17: {
                     ~~~~~
!!! error TS7010: 'foo17', which lacks return-type annotation, implicitly has an 'any' return type.
        <T extends Derived>(x: (a: T) => T): T[];
        <T extends Base>(x: (a: T) => T): T[];        
    });
    declare function foo17(a: any): any;
    
    declare function foo18(a18: {
                     ~~~~~
!!! error TS7010: 'foo18', which lacks return-type annotation, implicitly has an 'any' return type.
        (x: {
            <T extends Derived>(a: T): T;
            <T extends Base>(a: T): T;
        }): any[];
        (x: {
            <T extends Derived2>(a: T): T;
            <T extends Base>(a: T): T;
        }): any[];
    });
    declare function foo18(a: any): any;
    
    var r1arg = <T>(x: T) => <T[]>null;
                             ~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r1arg2 = <T>(x: T) => <T[]>null;
                              ~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r1 = foo1(r1arg);
    var r1a = [r1arg, r1arg2];
    var r1b = [r1arg2, r1arg];
    
    var r2arg = <T>(x: T) => [''];
    var r2arg2 = <T>(x: T) => [''];
    var r2 = foo2(r2arg);
    var r2a = [r2arg, r2arg2];
    var r2b = [r2arg2, r2arg];
    
    var r3arg = <T>(x: T) => <T>null;
    var r3arg2 = <T>(x: T) => { };
    var r3 = foo3(r3arg);
    var r3a = [r3arg, r3arg2];
    var r3b = [r3arg2, r3arg];
    
    var r4arg = <T, U>(x: T, y: U) => '';
    var r4arg2 = <T, U>(x: T, y: U) => '';
    var r4 = foo4(r4arg);
    var r4a = [r4arg, r4arg2];
    var r4b = [r4arg2, r4arg];
    
    var r5arg = <T, U>(x: (arg: T) => U) => <T>null;
    var r5arg2 = <T, U>(x: (arg: T) => U) => <T>null;
    var r5 = foo5(r5arg);
    var r5a = [r5arg, r5arg2];
    var r5b = [r5arg2, r5arg];
    
    var r6arg = <T extends Base, U extends Derived>(x: (arg: T) => U) => <T>null;
                                                                         ~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'T' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
!!! error TS2352:   'T' could be instantiated with an arbitrary type which could be unrelated to 'null'.
    var r6arg2 = <T extends Base>(x: (arg: T) => Derived) => <T>null;
                                                             ~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'T' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
!!! error TS2352:   'T' could be instantiated with an arbitrary type which could be unrelated to 'null'.
    var r6 = foo6(r6arg);
    var r6a = [r6arg, r6arg2];
    var r6b = [r6arg2, r6arg];
    
    var r11arg = <T, U>(x: { foo: T }, y: { foo: U; bar: U }) => <Base>null;
                                                                 ~~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'Base' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r11arg2 = <T>(x: { foo: T }, y: { foo: T; bar: T }) => <Base>null;
                                                               ~~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'Base' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r11 = foo11(r11arg);
    var r11a = [r11arg, r11arg2];
    var r11b = [r11arg2, r11arg];
    
    var r15arg = <U, V>(x: { a: U; b: V; }) => <U[]>null;
                                               ~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'U[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r15arg2 = <T>(x: { a: T; b: T }) => <T[]>null;
                                            ~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r15 = foo15(r15arg);
    var r15a = [r15arg, r15arg2];
    var r15b = [r15arg2, r15arg];
    
    var r16arg = <T extends Base>(x: { a: T; b: T }) => <T[]>null;
                                                        ~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r16arg2 = <T extends Base>(x: { a: T; b: T }) => <T[]>null;
                                                         ~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r16 = foo16(r16arg);
    var r16a = [r16arg, r16arg2];
    var r16b = [r16arg2, r16arg];
    
    var r17arg = <T>(x: (a: T) => T) => <T[]>null;
                                        ~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'T[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r17 = foo17(r17arg);
    
    var r18arg = (x: <T>(a: T) => T) => <any[]>null;
                                        ~~~~~~~~~~~
!!! error TS2352: Conversion of type 'null' to type 'any[]' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
    var r18 = foo18(r18arg);