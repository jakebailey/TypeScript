propertyAccessOnTypeParameterWithConstraints5.ts(14,17): error TS2454: Variable 'x' is used before being assigned.
propertyAccessOnTypeParameterWithConstraints5.ts(15,20): error TS2454: Variable 'x' is used before being assigned.
propertyAccessOnTypeParameterWithConstraints5.ts(15,30): error TS2454: Variable 'x' is used before being assigned.
propertyAccessOnTypeParameterWithConstraints5.ts(15,32): error TS2339: Property 'notHere' does not exist on type 'U'.
propertyAccessOnTypeParameterWithConstraints5.ts(25,10): error TS2454: Variable 'i' is used before being assigned.
propertyAccessOnTypeParameterWithConstraints5.ts(25,16): error TS2339: Property 'notHere' does not exist on type 'B'.
propertyAccessOnTypeParameterWithConstraints5.ts(26,11): error TS2454: Variable 'i' is used before being assigned.
propertyAccessOnTypeParameterWithConstraints5.ts(32,18): error TS2454: Variable 'a' is used before being assigned.
propertyAccessOnTypeParameterWithConstraints5.ts(32,22): error TS2339: Property 'notHere' does not exist on type 'A'.
propertyAccessOnTypeParameterWithConstraints5.ts(33,19): error TS2454: Variable 'a' is used before being assigned.
propertyAccessOnTypeParameterWithConstraints5.ts(35,5): error TS7022: 'b' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
propertyAccessOnTypeParameterWithConstraints5.ts(38,9): error TS2322: Type 'string' is not assignable to type 'U'.
  'U' could be instantiated with an arbitrary type which could be unrelated to 'string'.
propertyAccessOnTypeParameterWithConstraints5.ts(38,22): error TS2339: Property 'notHere' does not exist on type 'U'.


==== propertyAccessOnTypeParameterWithConstraints5.ts (13 errors) ====
    class A {
        foo(): string { return ''; }
    }
    
    class B extends A {
        bar(): string {
            return '';
        }
    }
    
    class C<U extends T, T extends A> {
        f() {
            var x: U;
            var a = x['foo'](); // should be string
                    ~
!!! error TS2454: Variable 'x' is used before being assigned.
            return a + x.foo() + x.notHere();
                       ~
!!! error TS2454: Variable 'x' is used before being assigned.
                                 ~
!!! error TS2454: Variable 'x' is used before being assigned.
                                   ~~~~~~~
!!! error TS2339: Property 'notHere' does not exist on type 'U'.
        }
    }
    
    var r = (new C<B, A>()).f();
    
    interface I<U extends T, T extends A> {
        foo: U;
    }
    var i: I<B, A>;
    var r2 = i.foo.notHere();
             ~
!!! error TS2454: Variable 'i' is used before being assigned.
                   ~~~~~~~
!!! error TS2339: Property 'notHere' does not exist on type 'B'.
    var r2b = i.foo['foo']();
              ~
!!! error TS2454: Variable 'i' is used before being assigned.
    
    var a: {
        <U extends T, T extends A>(): U;
    }
    // BUG 794164
    var r3: string = a().notHere();
                     ~
!!! error TS2454: Variable 'a' is used before being assigned.
                         ~~~~~~~
!!! error TS2339: Property 'notHere' does not exist on type 'A'.
    var r3b: string = a()['foo']();
                      ~
!!! error TS2454: Variable 'a' is used before being assigned.
    
    var b = {
        ~
!!! error TS7022: 'b' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
        foo: <U extends T, T extends A>(x: U): U => {
            var a = x['foo'](); // should be string
            return a + x.notHere();
            ~~~~~~
!!! error TS2322: Type 'string' is not assignable to type 'U'.
!!! error TS2322:   'U' could be instantiated with an arbitrary type which could be unrelated to 'string'.
                         ~~~~~~~
!!! error TS2339: Property 'notHere' does not exist on type 'U'.
        },
        // BUG 794164
        bar: b.foo(1).notHere()
    }
    
    var r4 = b.foo(new B()); // error after constraints above made illegal, doesn't matter